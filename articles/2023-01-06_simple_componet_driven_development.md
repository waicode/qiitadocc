<!--
title:   Storybookとはじめる難しく考え過ぎないコンポーネント駆動開発
tags:    フロントエンド,storybook,Vue.js
private: true
-->

# 小規模な画面開発でもコンポーネント駆動の恩恵は受けられる

TODO: つかみとまとめ。

# Atomic Designは難しい

Atomic Designをはじめとするデザインパターンを導入すると、拡張性や再利用性が高まります。

画面数が多い・複雑度の高い開発では恩恵を受けやすくなる一方で、今回の規模では正直やり過ぎ感がありました。

そこで、コンポーネントの粒度を決定する基準を極力シンプルにしました。

## 汎用コンポーネント

テキストやボタンなど、汎用的なコンポーネントです。
イメージとしては、他システムへ該当コンポーネントをそのまま移して使っても違和感が無い、
大きな調整が不要なコンポーネントです。

複雑度を下げるため、汎用コンポーネントの中で別の汎用コンポーネントを呼び出すことは意図的に行いませんでした。

## 画面の役割を持つコンポーネント

名付けをあきらめてそのまま説明を書いてしましましたが、
たとえば「バーコード表示エリア」など、その画面が持つ役割を何かしら担っているコンポーネントです。
コンポーネントが画面固有のデザインを持っている場合も、汎用コンポーネントでなくこちらに分類されます。

これらのコンポーネントは、単体のコンポーネントで成立する場合もあれば、
汎用コンポーネントを含む複数のコンポーネントの組み合わせで実現することもあります。

ここでドメインという言葉を使うのが適切かどうか分かりませんが、
イメージとしては、その画面のドメインに関与しているかどうかがコンポーネント決定における唯一の基準です。

# ページはコンポーネントの組み合わせで構築する

もう１つの基準として、あらゆるページをコンポーネントの組み合わせのみで実現させます。

複雑度の高くない、ちょっとした画面要素の場合、
ついついページ側に直接書きたくなってしまいますが、
ここは「画面の役割を持つコンポーネント」を用意してページ側から読み込むことを徹底しました。

のちのち仕様変更が入った際の影響をコンポーネントに閉じることができます。

# コンポーネントは3点セットで開発

このシステムはVue/Nuxtを使って実装しました。

コンポーネント開発をするときは以下の3点セットで開発することを標準ルールにしました。

- 画面描画を担うコンポーネントファイル（`componentName.vue`）
- コンポーネント固有の処理をまとめたファイル（`componentNameComposable.ts`）
- コンポーネントのStorybookファイル（`componentName.stories.ts`）

コンポーネント固有の処理をまとめたファイルを別途設けているのは、
Vue特有の事情も少し含まれてきます。`.ts` ファイルとして独立させておいた方が、
Storybookとの定義共有やユニットテストのやりやすさが上がるためです。

なお、コンポーネント固有でなく汎用的に使われる処理は別の場所でComposableとしてまとめます。

# スタイルは画面描画を担うコンポーネントにだけ書く

せっかくコンポーネント分割したのに、
スタイル記述の影響がコンポーネントを跨いでしまうと、
影響範囲をコンポーネントに閉じ込めることができません。

スタイルのコーディング規約はBEMを採用し、
前述の「画面描画を担うコンポーネントファイル」にだけ記述します。
リセットCSSやミックスインを除き、グローバルに書くスタイルはありません。

共通変数はグローバルに定義して一覧性を上げ、各コンポーネントからそれを参照します。
stylelintのプラグインでリテラル値の直接指定を禁止することで、
ルールから逸脱しない設定値の指定が可能です。

# 見た目のテストは画面キャプチャで楽をする

Storybookを使ったコンポーネント駆動開発の恩恵は、
将来的な保守開発を含めて開発生産性が上がることはもちろんですが、
見た目のテストが楽できることも無視できません。

このプロジェクトではPlaywrightを使って、
コンポーネントの組み合わせで構成されたページの見た目を
ビジュアルリグレッションテストしています。
一度、期待値となる画面のスクリーンショットを撮れば、
意図しない見た目の変更検知が可能になります。

より厳しく確認したければ、コンポーネント単位でやってもよいですのですが、
状態変化を含むすべてのページのキャプチャを撮れば、コンポーネントを網羅的にテスト可能です。
これは、ページがすべてのコンポーネントの組み合わせで作られているためです。

なお、見た目でなく「コンポーネント固有の処理」「汎用的に使われる処理」については、
すべてユニットテストを書きます。見た目とは独立して `.ts` ファイルが存在していることで、
テスト対象の処理を漏れなく確認しやすくなるメリットもあります。
